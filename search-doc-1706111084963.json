{"searchDocs":[{"title":"Contribution","type":0,"sectionRef":"#","url":"/docs/diy/contribution","content":"Contribution Work in progress","keywords":"","version":"Next"},{"title":"Create custom templates","type":0,"sectionRef":"#","url":"/docs/diy/create-custom-template","content":"Create custom templates Work in progress","keywords":"","version":"Next"},{"title":"CHANGELOG","type":0,"sectionRef":"#","url":"/docs/CHANGELOG","content":"","keywords":"","version":"Next"},{"title":"0.2.0 (2023-09-26))​","type":1,"pageTitle":"CHANGELOG","url":"/docs/CHANGELOG#020-2023-09-26","content":" New Features​  Environment and Environment provider entity typesMulti-account and multi-region supportEnvironment and Environment provider provisioning from BackstageGitLab pipelines for CI/CD to build and deploy applicationsDynamic pipelines for new environment deploymentsEnvironment addition at application levelIntroduce environment hierarchy/level and require approval options for AWS EnvironmentApplication auditing per environmentEnvironment selector drop down - Contextual environment switching for applicationsResource template for RDSResource Binding to applicationsAWS-Resource Backstage PageApp Pending page - while pipeline is still provisioning the app/resourceJava SpringBoot templateDelete App &amp; Delete Provider capabilitiesServerless and ECS environment provider examplesPermissions framework adoptionInstallation improvements  0.1.0 (2023-04-10)​  New Features​  initial release ","version":"Next","tagName":"h3"},{"title":"Create pipelines patterns","type":0,"sectionRef":"#","url":"/docs/diy/create-pipelines-patterns","content":"Create pipelines patterns Work in progress","keywords":"","version":"Next"},{"title":"Design your platform","type":0,"sectionRef":"#","url":"/docs/diy/design-your-platform","content":"Design your platform Work in progress","keywords":"","version":"Next"},{"title":"Customizing security","type":0,"sectionRef":"#","url":"/docs/diy/customizing-security","content":"Customizing security Work in progress","keywords":"","version":"Next"},{"title":"Intro","type":0,"sectionRef":"#","url":"/docs/intro","content":"","keywords":"","version":"Next"},{"title":"What is OPA on AWS?​","type":1,"pageTitle":"Intro","url":"/docs/intro#what-is-opa-on-aws","content":" Orchestrate Platforms and Application (OPA) on AWS brings the AWS cloud closer to your developers. The platform allows enterprise customers to build environments and applications on AWS without requiring application developers to upskill on cloud expertise. OPA on AWS is a reference implementation for an enterprise grade fully integrated internal developer platform. Improving the developer's workflow with a secure and scalable experience for non-cloud developers.  OPA on AWS is built on a Cloud Native Computing Foundation (CNCF) project, Backstage, which is an open platform for building developer portals. The Backstage platform itself has been adopted by over 900 companies as their primary developer portal in the past 3 years and has over 100 plugins available for its end users. OPA on AWS takes Backstage to the next level by seamlessly integrating it with AWS and packaging it together for enterprise use.  ","version":"Next","tagName":"h2"},{"title":"Why did we build OPA on AWS?​","type":1,"pageTitle":"Intro","url":"/docs/intro#why-did-we-build-opa-on-aws","content":" Enterprise customers are challenged to integrate with AWS Services while adhering to their operation standards, security guardrails and compliance. In addition, cloud engineers and dev-ops teams are a scarce resource that do not scale. Platform engineering helps to reduce this bottleneck and to enable enterprises to scale and improve their developer experience and the use of AWS Services securely.  ","version":"Next","tagName":"h2"},{"title":"What's included?​","type":1,"pageTitle":"Intro","url":"/docs/intro#whats-included","content":" The open source solution includes the following:  Complete source code to provision a new platform.Templates and examples to create environments, providers, applications and AWS resources.Backstage plugins and plugins source code.Predefined CI/CD centralized pipelines for more than 12 common patterns.Documentation, support videos, and a workshop.  Refer to the features page for a complete list of capabilities.  ","version":"Next","tagName":"h2"},{"title":"Getting Started​","type":1,"pageTitle":"Intro","url":"/docs/intro#getting-started","content":" Get started by creating a new platform ","version":"Next","tagName":"h2"},{"title":"Migration from on-prem to OPA on AWS","type":0,"sectionRef":"#","url":"/docs/migrations/migration-onprem","content":"Migration from on-prem to OPA on AWS Work in progress","keywords":"","version":"Next"},{"title":"Features","type":0,"sectionRef":"#","url":"/docs/features","content":"","keywords":"","version":"Next"},{"title":"Version 0.2​","type":1,"pageTitle":"Features","url":"/docs/features#version-02","content":" ","version":"Next","tagName":"h2"},{"title":"1. Platform engineer scope​","type":1,"pageTitle":"Features","url":"/docs/features#1-platform-engineer-scope","content":" Feature\tDescriptionDynamic environment provider provisioning\tCreate unlimited number of providers on multiple accounts and regions ECS environment provider\tCreate an ECS (Elastic container servicer) based provider Serverless environment provider\tCreate a serverless based provider Abstracted AWS environment\tCreate a environment of which applications and resources can be created Application pipeline\tCreate a pipeline for each application to support IAC provisioning and code change stage Environment Deployment pipeline\tCreate a pipeline to deploy the code base of an application to another environment Resource Binding\tAllow Binding resources to application to provide access and sharing capabilities for AWS resources Deploy to additional environments\tAllow the deployment of an application to additional environments Environments selector\tToggle between the environments of which the application is deployed and present relevant information for the current selected environment Segregated auditing\tAudit actions from platform and pipeline to a segregated auditing table of the target environment Environment level\tAllow to define a number representing the level of the environment thus creates hierarchies that are used for deployments Deployment requires approval\tConfigure how the pipelines should execute against an environment automatic / require approval Delete app\tRemove an application from an environment Delete provider\tRemove a provider Centralized pipelines\tLoad pipelines dynamically from a centralized repository Component Pending page\tPresent a partial page while the component IAC pipeline is still processing Terraform/CDK pipelines\tSupport both terraform and CDK pipelines to provision resources  ","version":"Next","tagName":"h3"},{"title":"2. Application developer scope​","type":1,"pageTitle":"Features","url":"/docs/features#2-application-developer-scope","content":" Feature\tDescriptionClone repository while resources are provisioned\tThe ability to clone the repository immediately after it was created without waiting for the pipeline to provision the infrastructure Start and stop ECS task\tStart and stop the ECS task to load the latest container changes Change ECS task environment variable\tChange the ECS Task definition environment variables to inject new parameters to the app runtime View related app cloud resources\tView related application resources that are provisioned for this app View application logs\tView the CloudWatch logs for the application Visualize application software catalog relationship\tView the application relationship including environments, shared resources and owner Automatic deployment for additional environment\tDeploy the application to another environment with a click of a button Delete app\tDelete the application and it's related resources Bind application to resource\tPermit an application to use a shared resource such as RDS database, S3 bucket, EFS etc. View application CI/CD pipelines\tView the application CI/CD pipelines  ","version":"Next","tagName":"h3"},{"title":"Coming up​","type":1,"pageTitle":"Features","url":"/docs/features#coming-up","content":" Feature\tScope\tDescription\tTimelineEKS environment provider\tPlatform Engineer\tCreate a Kubernetes based provider\tJan 2024 Environment Binding\tPlatform Engineer\tBind Environments to allow network communication across multiple VPC's through AWS Transit gateway\tFebruary 2024  ","version":"Next","tagName":"h2"},{"title":"Provided examples and templates​","type":1,"pageTitle":"Features","url":"/docs/features#provided-examples-and-templates","content":" Feature\tDescription\tTypeAWS ECS Environment Provider\ta provider IAC for ECS runtime\tProvider AWS Serverless Environment Provider\ta provider IAC for Serverless runtime\tProvider AWS RDS Database\tan RDS database template\tResource Node.js Terraform Web App\ta node.js application provisioning by terraform\tApplication Node.js Express Web App With RDS\ta node.js application with a baked in starter code to connect to RDS database\tApplication Node.js Express Web App\ta node.js application\tApplication Python Flask starter application\ta python flask web server application\tApplication Serverless REST API (TypeScript)\ta lambda based serverless REST API application template for typescript\tApplication Java Spring Boot Web Service\ta java springboot application\tApplication  ","version":"Next","tagName":"h2"},{"title":"Backlog​","type":1,"pageTitle":"Features","url":"/docs/features#backlog","content":" Feature\tScope\tDescription ","version":"Next","tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/getting-started/deploy-the-platform","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"Installation","url":"/docs/getting-started/deploy-the-platform#prerequisites","content":" ","version":"Next","tagName":"h2"},{"title":"Software prerequisites​","type":1,"pageTitle":"Installation","url":"/docs/getting-started/deploy-the-platform#software-prerequisites","content":" The following software is required to perform the installation of the platform solution:  Unix-based operating system (Linux, MacOS, or the Windows Subsystem for Linux)node.js - 18.19 or higheryarn - v1.x (Yarn classic)aws-cliaws-cdkjqdockergit  note The installation instructions documented here were tested using the following versions: node v18.19aws-cdk v2.95yarn 1.22.21  ","version":"Next","tagName":"h3"},{"title":"Solution Platform prerequisites​","type":1,"pageTitle":"Installation","url":"/docs/getting-started/deploy-the-platform#solution-platform-prerequisites","content":" Prior to installing the OPA solution platform, you will need to ensure that the following items are configured and available:  AWS Account ID and region - The solution will be installed into an AWS account and region. You will need the 12-digit account ID and must be able to log into the account with sufficient permissions to provision infrastructure resources. GitLab Community Edition EC2 AMI id - The solution will install a small GitLab instance where application source code will be stored. The AWS Marketplace provides a free, community edition of GitLab used by the solution. You will need to subscribe to the AWS Marketplace offering. Search for &quot;GitLab Community Edition&quot; by GitLab or use a direct link: https://aws.amazon.com/marketplace/pp/prodview-w6ykryurkesjqOnce your account is subscribed to the GitLab CE Marketplace offering, save the EC2 AMI for the appropriate region from the &quot;Launch new instance&quot; page as shown in the image below (do not actually launch an instance as this will be done for you during installation). Alternatively, you can query for the AMI using the AWS CLI (substitute the appropriate region value for the --region option): aws ec2 describe-images --owners &quot;aws-marketplace&quot; --filters &quot;Name=name,Values=*GitLab CE 16.4.0*&quot; --query 'Images[].[ImageId]' --region us-west-2 --output text GitLab Runner image - The solution will set up an EC2 instance as a GitLab Runner to execute GitLab CI/CD pipelines. The Amazon-provided &quot;Jammy&quot; image will be used for the runner image. Save the EC2 AMI for the appropriate region for this AMI. The following AMI command will return the appropriate image id. Replace the value for &quot;--region&quot; to reflect your target region: aws ec2 describe-images --owners &quot;amazon&quot; --filters &quot;Name=name,Values=*ubuntu-jammy-22.04-amd64-server-20230208*&quot; --query 'Images[].[ImageId]' --region us-west-2 --output text Route 53 Hosted Zone - The solution will ensure secure communcations and set up a certificate for your defined domain. Ensure that a public hosted zone is set up in your account. See the AWS documentation for creating a public hosted zone Okta authentication - The solution uses Okta and RoadieHQ Backstage plugins for authentication of users and groups. You will need a client id, client secret, and API key for configuration of the solution. If you wish to use Okta for authentication and do not have an existing account, you can sign up a free Workforce Identity Cloud developer account. Once the account is set up, you will need to configure an Okta API key for the RoadieHQ backend catalog pluginA client id and secret are required to set up a Backstage Okta authentication provider. See the Backstage Okta auth documentation for more details.Other identity providers are supported and could be substituted using different plugins. Configuring alternative authentication is not covered in this documentation. Refer to the Backstage Authentication documentation for details to install and configure alternative providers.  ","version":"Next","tagName":"h3"},{"title":"Installation​","type":1,"pageTitle":"Installation","url":"/docs/getting-started/deploy-the-platform#installation-1","content":" Clone the repository and change to the repository location git clone https://github.com/awslabs/app-development-for-backstage-io-on-aws.git cd app-development-for-backstage-io-on-aws Configure the solution Copy the config/sample.env file to config/.envEdit the config/.env file and provide values for all of the environment variables. The file is commented to explain the purpose of the variables and requires some of the information from the Solution Platform Prerequisites section above. info The SECRET_GITLAB_CONFIG_PROP_apiToken variable does not need to be provided. This will be automatically configured during installation after the platform is deployed. Perform the installation Run make install The Makefile target will automatically perform the following actions: Install and configure BackstageInstall/update CDKDeploy the solution platform AWS infrastructureUpdate the configuration with GitLab informationPush a sample repository to GitLabBuild and deploy the Backstage image to AWS After the installation completes, the application will start up. Open a browser and navigate to the 'OPA on AWS' endpoint using the Route 53 hosted zone name that you configured (e.g. https://${R53_HOSTED_ZONE_NAME}). If any errors occur during installation, please review the install_{datestamp}.log file for details.  ","version":"Next","tagName":"h2"},{"title":"Installation FAQs​","type":1,"pageTitle":"Installation","url":"/docs/getting-started/deploy-the-platform#installation-faqs","content":" I don't use Okta. Can i change the identity provider to another one?  Yes. Backstage supports many identity providers. Once you configure Backstage for your chosen provider, make sure the Backstage catalog is synced with the users and groups from your provider.    I want to use another source control that is not GitLab. How can i do that?  Backstage supports multiple source control providers which can be integrated through the Backstage config. OPA uses GitLab for several usage scenarios which you will need to migrate to another source control provider: Storing application source codeStoring template source codeStoring pipelines jobs and orchestrationUpdate the Client API plugin that interacts with GitLab to the new source control provider    I'm using Terraform, can I use this solution with Terraform to provision application resources?  Yes. We provide a Node.js Terraform application software template for demonstration. You may also write your own provider with Terraform.    For more Q &amp; A please see our FAQ Page ","version":"Next","tagName":"h2"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/docs/faq","content":"FAQ What is OPA on AWS?​ Orchestrate Platforms and Applications (OPA) on AWS is an open source reference implementation that ties together AWS services into an enterprise ready solution. By abstracting AWS services, OPA on AWS allows application developers to focus on what they do best – writing application logic code, all while allowing platform engineering teams to enforce internal guardrails and best practices at scale. OPA on AWS provides a productive and efficient experience for non-cloud developers and allows for integrations with your current tooling. It is fast, safe, fun, and at-scale. What does OPA on AWS do?​ OPA on AWS provides a comprehensive Internal Developer Platform solution. It allows developers to write application logic, on AWS, without having to know how to provision and manage AWS services. OPA on AWS also allows platform engineering teams to easily manage all the resources and applications that run on AWS. What was the motivation behind building OPA on AWS?​ Enterprise are challenged to integrate with AWS while adhering to their standards, security guardrails and compliance. In addition, cloud engineers are a scarce resource that does not scale. Using platform engineering, this gap is shortened, thus enabling enterprise to improve their developer experience and scales the use of AWS Services securely. Is OPA on AWS an AWS Service?​ No, OPA on AWS is not a managed service. It is an open source platform reference implementation supporting integration with AWS Services for enterprises. Since OPA on AWS is using native AWS Services, it provides all the benefits and scale that AWS can offer along with a productive developer experience Who is the audience for OPA on AWS?​ OPA on AWS binds the AWS services into an enterprise ready offering. It was originally built for financial enterprise use cases to accommodate for security and regulatory compliance needs and the necessity for scale and efficiency. It is applicable for every company interested in scaling while still keeping the same tooling and additional internal and external standards. What support do you offer? How can I learn to use OPA on AWS?​ OPA on AWS is accompanied with documentation, detailed ReadMes, and a series of YouTube videos. All of these resources can help you learn more about the solution and get started. For any issue beyond the current available information, you can reach us by opening an issue via GitHub What is OPA on AWS’s license?​ OPA on AWS is licensed as Apache-2.0. What are the benefits for using OPA?​ A better developer experience and faster way to scale the use of AWS Services for enterprises. Please see the full features page What are the requirements to get started on OPA?​ Please read our documentation Getting started What is the price of OPA?​ OPA on AWS is free open source project. However the use of AWS Services is as per the service pricing of each service you use Is there a roadmap?​ Please see the features section under features Why is OPA on AWS integrated with Backstage?​ Backstage.io is a mature CNCF project, and has been widely adopted across the market. By integrating with Backstage.io, users of OPA on AWS can benefit from +100 plugins and a large community (+20k). This allows customers to customize their environments, and keep existing tooling, while still working on AWS. Building on Backstage.io has helped to expedite the journey of OPA on AWS, and bring more value to our customers. How can OPA on AWS accelerate applications migration?​ Please see our Migration page What happens if Backstage.io releases an update? How will OPA on AWS accommodate updates?​ OPA on AWS lists the latest tested version of Backstage.io with OPA on AWS plugins. The solution is decoupled from Backstage.io, therefore it should be possible to upgrade backstage and install the plugins afterwards. However, Backstage.io may introduce breaking changes and therefore we publish the last tested plugin version. How can I report bugs or submit feature requests?​ Please submit any issues and requests via the public repository Will AWS supply templates or examples? How will they be maintained?​ There are many samples and examples provided, please see this table. Will this make the DevOps team obsolete?​ OPA on AWS helps scale DevOps teams and enables the development teams to own their infrastructure and applications and reduce the bottleneck from the DevOps team. How secure is this solution? Has it been reviewed by a third party?​ The solution was designed for a large financial customer adhering to financial services customer regulation and AWS best practices. The solution have been through an AWS security review. How does OPA on AWS differ from AWS console?​ OPA on AWS aims to provide a productive, efficient, and delightful developer experience by providing a simplified way to use AWS. By nature, the AWS console will enable the skilled cloud engineer to fine-tune and define their needs, however, OPA on AWS will enable a persona to build on AWS without having to know how to operate all the knobs and dials. What is an Internal Developing Platform (IDP)?​ Please refer to platformengineering.org Does OPA on AWS have a CLI?​ Not yet - Please see features Have an additional question? Reach out to us at fsi-pace-pe@amazon.com","keywords":"","version":"Next"},{"title":"Architecture","type":0,"sectionRef":"#","url":"/docs/techdocs/architecture","content":"","keywords":"","version":"Next"},{"title":"OPA Platform​","type":1,"pageTitle":"Architecture","url":"/docs/techdocs/architecture#opa-platform","content":" The below diagram illustrates the major components of the OPA platform.  The platform creation is automated by way of executing an AWS CDK script that will provision the needed resources in your AWS account. After running the script, you will have the Backstage developer portal running on AWS and it will be set up to persist its configurations to an RDS database. Backstage will be integrated with an identity provider to facilitate user logins. The default identity provider is Okta, but you can customize this to use a different one.  Backstage is also integrated with a version control system. It is configured to discover entity definition files in existing Git repositories so that these entities will show up in the portal. Backstage will also be able to create new repositories to hold the source code of applications and other resources that are created by portal users.  The default OPA version control system is GitLab. The platform creation scripts will set up a Community Edition of GitLab that runs on AWS, so that it can be used for demonstration purposes. It is possible through code modifications to switch to a different version control vendor that can be hosted on or outside of the AWS cloud.      ","version":"Next","tagName":"h2"},{"title":"Application Environments​","type":1,"pageTitle":"Architecture","url":"/docs/techdocs/architecture#application-environments","content":" The below diagram illustrates the relationships between an application and the environments it gets deployed to.  An environment is just a Backstage entity that contains metadata and associations with other entities such as applications and providers. Environment providers are more than just Backstage entities. Providers are backed by Git repositories that contain Infrastructure as Code scripts that provision resources to a specific AWS account and region. The provider's resources are created to support running applications of a certain type, such as containerized apps that will be run on a cluster or serverless apps.      ","version":"Next","tagName":"h2"},{"title":"AWS Cloud Components of an Environment Provider​","type":1,"pageTitle":"Architecture","url":"/docs/techdocs/architecture#aws-cloud-components-of-an-environment-provider","content":" The below diagram illustrates the AWS cloud components that make up an environment provider that could be used to host a containerized application.  Every provider must include a security role for Backstage CICD pipelines to use to provision and update applications in a specific AWS account and region. Providers's must also contain an operations role, which is assumed by the Backstage portal to grant it access to execute the operations that portal users are choosing. The final requirement of a provider is that it must contain an audit table, which OPA uses to track user actions made to applications running on the provider's account.  Providers can also commonly include networking configurations, encryption keys, and secrets.      ","version":"Next","tagName":"h2"},{"title":"How an Application Gets Created​","type":1,"pageTitle":"Architecture","url":"/docs/techdocs/architecture#how-an-application-gets-created","content":" Applications are created when developers log into Backstage and select an existing application template that meets their needs. They are then asked to fill in a form with vital information, such as the application's name and the environment it will run on.  Backstage will create a new Git repository to hold the application's code, its CICD pipeline definition, and its Backstage entity definition. Backstage reads the entity definition so that the new application will show up on the portal.  When the Git repository is created, its CICD pipeline will execute, resulting in resources being provisioned on AWS. Once the pipeline has finished, Backstage users will be able to see many attributes of the application, such as its running state and logs. They will also be able to perform operations on the application, such as changing environment variables or pushing a new release.      ","version":"Next","tagName":"h2"},{"title":"Application CICD Pipeline​","type":1,"pageTitle":"Architecture","url":"/docs/techdocs/architecture#application-cicd-pipeline","content":" The below diagram illustrates an application's CICD pipeline. The application is associated with 3 environments (DEV, QA, PROD).  OPA is able to create pipelines like this for you when it creates a new application. These pipelines are capable of deploying to as many AWS accounts as you need.     ","version":"Next","tagName":"h2"},{"title":"Migration from PCF to OPA on AWS","type":0,"sectionRef":"#","url":"/docs/migrations/migration-pcf","content":"Migration from PCF to OPA on AWS Work in progress","keywords":"","version":"Next"},{"title":"Migration from OpenShift to OPA on AWS","type":0,"sectionRef":"#","url":"/docs/migrations/migration-openshift","content":"Migration from OpenShift to OPA on AWS Work in progress","keywords":"","version":"Next"},{"title":"Plugins","type":0,"sectionRef":"#","url":"/docs/techdocs/plugins","content":"","keywords":"","version":"Next"},{"title":"Architecture​","type":1,"pageTitle":"Plugins","url":"/docs/techdocs/plugins#architecture","content":"     Backstage Plugins description  Plugin\tType\tDescriptionBackend - @aws/plugin-aws-apps-backend-for-backstage\tBackstage backend plugin\tresponsible for all outgoing API calls to AWS, SCM (Gitlab) and the platform Frontend - @aws/plugin-aws-apps-for-backstage\tBackstage frontend plugin\tresponsible for all UI interaction components - pages, components, state and frontend API Common - @aws/plugin-aws-apps-common-for-backstage\tBackstage isomorphic plugin\tshareable plugin for both frontend, backend and scaffolder, used to define interfaces and types Scaffolder - @aws/plugin-scaffolder-backend-aws-apps-for-backstage\tBackstage scaffolder plugin\tcontains the actions required to execute the templates  tip For more information on backstage plugins visit Backstage plugin documentation  ","version":"Next","tagName":"h2"},{"title":"Plugin dependencies​","type":1,"pageTitle":"Plugins","url":"/docs/techdocs/plugins#plugin-dependencies","content":"   ","version":"Next","tagName":"h2"},{"title":"Plugin source code​","type":1,"pageTitle":"Plugins","url":"/docs/techdocs/plugins#plugin-source-code","content":" Backend pluginFrontend pluginCommon pluginScaffolder plugin ","version":"Next","tagName":"h2"},{"title":"Processes","type":0,"sectionRef":"#","url":"/docs/techdocs/process","content":"","keywords":"","version":"Next"},{"title":"Deploying a template​","type":1,"pageTitle":"Processes","url":"/docs/techdocs/process#deploying-a-template","content":" info The process described below is true for all templates with the exception of AWS Environment.  When a user selects a template in the catalog and clicks Create, the below process is initiated.    Template Creation: The process of filling the template with the required input from the user, text fields, selecting other entities, choosing options etc.Rendered Entity Data: Based on the previous selection, this process will fetch all the required data before populating the repository. This includes information about the selected environment entity, platform configurations and entity rendered data. You can see the result of this process in the generated repository right after creation. This process make use of the Scaffolder actions plugin.Create Repository: Create the git repository for the entity, code, IaC and environment information. Based on the type of template, the repository will be created in a git project group: environments, environment-providers, aws-app, aws-resources. This allows us to segregate access control from managing repositories under different security domains.Store initial files and pipeline: Persisting the generated files from step 2 in the repository including the particular pipeline pattern that fits the selected template (See below for more details on pipeline process).Pipeline execution: Using Gitlab runner executing the pipeline in a separate shell. For building container images, we use Docker in Docker with Paketo build packs or KanikoGet Credentials: Fetch credentials from the target (Environment provider) provisioning role in order to provision the IAC for the template.Provision IaC: Provision the IaC against the target destination (Environment provider) - cdk deploy / terraform applyUpdate Entity catalog: Based on step 7 select the desired IaC deployment output and update the entity catalog file (catalog-info.yaml) with the resources information.  ","version":"Next","tagName":"h2"},{"title":"Executing Gitlab pipeline​","type":1,"pageTitle":"Processes","url":"/docs/techdocs/process#executing-gitlab-pipeline","content":" The pipeline execution process is composed of several patterns and abstractions. This was done for several reasons, but mostly for reusability and security controls.  ","version":"Next","tagName":"h2"},{"title":"Abstracted centralized pipelines​","type":1,"pageTitle":"Processes","url":"/docs/techdocs/process#abstracted-centralized-pipelines","content":" In order to allow updates and changes for pipelines that may be enforced by the platform engineering team, we externalized some of the pipeline actions and provide only the necessary variables as an input.  .gitlab-ci.yml stages: - env-creation - prepare-dev-stage - dev-stage variables: APP_SHORT_NAME: &quot;my-app&quot; APP_TEMPLATE_NAME: &quot;example-nodejs&quot; OPA_PLATFORM_REGION: &quot;us-east-1&quot; include: - project: 'opa-admin/backstage-reference' ref: main file: - 'common/cicd/.gitlab-ci-job-defaults-cdk.yml' - 'common/cicd/.gitlab-ci-aws-base.yml' - 'common/cicd/.gitlab-ci-aws-iac-ecs.yml' - 'common/cicd/.gitlab-ci-aws-image-kaniko.yml'   The first part of our pipeline, &quot;stages&quot;, defines the stages of this pipeline for the current state. This part is not fixed, we may introduce more stages when our application will be deployed to additional environments. Nonetheless we can see the first two stages for our dev environment:  prepare-dev-stage - this stage provisions and prepares the environment to be able to run the application before we start making continuous code changes to our repositories.dev-stage - this stage is responsible for compiling, building and deploying new versions of our application each time we push new code changes to our application logic (/src directory)  The env-creation is the stage to create the two stages above, the reason this is a stage on it's own is because we can reuse it to create more stages later, when the application is deployed to other environments.  tip The include clause allows us to dynamically pull pipelines from another repository each time the pipeline will run.  ","version":"Next","tagName":"h3"},{"title":"Modular pipelines​","type":1,"pageTitle":"Processes","url":"/docs/techdocs/process#modular-pipelines","content":" The idea of modular pipelines is to include smaller pipelines that contain jobs which together can provide a building block for different pipeline orchestrations. You may have already noticed from the example above we use several include statements. These statements help to reuse similar functionally for different templates / application patterns.  The complete list of pipeline patterns is available at: CICD Directory  .gitlab-ci-aws-base.yml.gitlab-ci-aws-dind-spring-boot.yml.gitlab-ci-aws-iac-ecs.yml.gitlab-ci-aws-iac-rds.yml.gitlab-ci-aws-iac-serverless-api.yml.gitlab-ci-aws-iac-tf-ecs.yml.gitlab-ci-aws-image-kaniko.yml.gitlab-ci-aws-provider-ecs.yml.gitlab-ci-aws-provider-serverless.yml.gitlab-ci-aws-tf-base.yml.gitlab-ci-job-defaults-cdk.yml.gitlab-ci-job-defaults-tf.yml  ","version":"Next","tagName":"h3"},{"title":"Pipeline jobs​","type":1,"pageTitle":"Processes","url":"/docs/techdocs/process#pipeline-jobs","content":" There are several jobs imported into the pipeline based on the pattern you use. Below is an example of pipeline executions and the job for each one of them:      Initial commit create-ci-stages - The job creates new stages for a target environment with its providers. Added CICD environment stage iac-deployment-ENVXXX-ProviderYYY - the job provision IAC against the target environment/providerget-aws-creds-ENVXXX-ProviderYYY - the job gets credentials from the provisioning role of the target providerbuild-image-ENVXXX-ProviderYYY - the job build a new image from the /src directory and update the container imagedelete-aws-creds-ENVXXX-ProviderYYY - delete the temporary credentials so that they are not persisted in the repository updating entity details - update cataloginfo.yaml with the IaC metadata. There is no need to run the pipeline again after this update, which is why the pipeline is showing as &quot;Skipped&quot;.  ","version":"Next","tagName":"h3"},{"title":"Deploy an application to another environment​","type":1,"pageTitle":"Processes","url":"/docs/techdocs/process#deploy-an-application-to-another-environment","content":" The process of deploying an application to another environment works by utilizing the jobs and stage we describe above. To visualize how the git pipeline looks when performing a multi-environment deployment, let's look at the below diagram.      We can see that once we deploy an application to another environment we essentially created new stages for the new target environment.  tip The process to deploy an application to another environment is done by submitting a commit to git with a specific message generate CICD stages along with a properties file that contains the information of the new target environment. When the pipeline job runs, it will process the new file and create corresponding stages for the new target destination. This change will automatically execute the pipeline and stage to deploy the application to the new target environment.  ","version":"Next","tagName":"h2"},{"title":"Continuous deployment for app code​","type":1,"pageTitle":"Processes","url":"/docs/techdocs/process#continuous-deployment-for-app-code","content":" How do the application logic code changes propagate to multiple environments? For example - if we have the below pattern of commit on our repository - every time we merge changes to the main branch /src directory (Can be configured differently) the ENV-XXX-stage will be triggered.    If we have several stages for multiple environments, all of them will be triggered in the original order they were created in.    note If we configured the environment with &quot;Requires approval&quot;, the pipeline that pushes code changes will halt until an approval is granted. This is useful in cases where we want supervision of what changes are propagated to a sensitive environment. Additional security controls can also be implemented. ","version":"Next","tagName":"h3"},{"title":"Create Apps","type":0,"sectionRef":"#","url":"/docs/tutorials/create-app","content":"Create Apps In this tutorial, you will build out a new AWS microservice application and deploy it as a into an Environment. By deploying into an Environment designed to run containerized applications in AWS Elastic Container Service (ECS), the application will be automatically packaged and deployed for you as an ECS task in an ECS cluster. info This tutorial assumes that you have run the Create an Environment tutorial and expects input values from that setup. If you have created different Environment entities, then substitute the appropriate values. 1. In the OPA on AWS site, navigate to the Create... menu. Search for and select Node.js Express Web App. 2. Provide application input parameters and select Next Step Parameter\tValue\tDescriptionName\tdemo-app\tA unique identifier for the application Description\tNode.js demo application running on ECS\tDescriptive information about the application Owner\tSelect a group from the drop-down list to own the application\tThe group or user that will be responsible for the entity AWS Environment\tthe ecs-dev environment will be pre-selected since it is the only environment available\tThe AWS Environment in which you want to deploy your application to. The environment that we created in the previous step will already be selected for you 3. Provide Repository information and select Next Step Parameter\tValue\tDescriptionHost\tdefault value\tThe GitLab host name Owner Available\tdefault value\tThe GitLab namespace where this repository will belong to. It can be the name of organization, group, subgroup, user, or the project Repository\tdemo-app\tThe name for the git repository 4. Review your inputs and select Create Your application will begin to deploy. A Task Activity view will show you the progress of all of the actions executed to build out your application. This includes gathering environment information, creating secrets, scaffolding a new repository, creating an access token for the repo, and registering the entity with backstage.","keywords":"","version":"Next"},{"title":"Security","type":0,"sectionRef":"#","url":"/docs/techdocs/security","content":"","keywords":"","version":"Next"},{"title":"Authentication with Backstage​","type":1,"pageTitle":"Security","url":"/docs/techdocs/security#authentication-with-backstage","content":" OPA on AWS comes pre-configured to use OKTA as an Identity provider. While this demonstrates one type of identity provider, it can easily be changed to other common identity providers such as Active Directory or any other OAuth 2 supported provider.  info There are multiple Identity Providers that are supported by Backstage. For the complete list, consult the Backstage reference  ","version":"Next","tagName":"h2"},{"title":"Identity providers with Backstage​","type":1,"pageTitle":"Security","url":"/docs/techdocs/security#identity-providers-with-backstage","content":"   The configurations to use an external IDP with Backstage require mapping to Backstage schemas - in particular the &quot;Users&quot; and &quot;Groups&quot; Schemas. Backstage offers two kinds:  &quot;kind&quot;: &quot;Group&quot; &quot;kind&quot;: &quot;User&quot;   The prescribed relationship between them can be expressed as (Okta example):   { &quot;metadata&quot;: { &quot;namespace&quot;: &quot;default&quot;, &quot;annotations&quot;: { &quot;backstage.io/managed-by-location&quot;: &quot;okta-org:all&quot;, &quot;backstage.io/managed-by-origin-location&quot;: &quot;okta-org:all&quot; }, &quot;name&quot;: &quot;some user name&quot;, &quot;title&quot;: &quot;********@amazon.com&quot;, &quot;uid&quot;: &quot;44e7bc31-4343-4145-ba7a-37796d7df965&quot;, &quot;etag&quot;: &quot;15bd46919fe1befaea71cec3293584b82231e3db&quot; }, &quot;kind&quot;: &quot;User&quot;, &quot;apiVersion&quot;: &quot;backstage.io/v1alpha1&quot;, &quot;spec&quot;: { &quot;profile&quot;: { &quot;email&quot;: &quot;&quot;********@@amazon.com&quot; }, &quot;memberOf&quot;: [] }, &quot;relations&quot;: [ { &quot;type&quot;: &quot;memberOf&quot;, &quot;targetRef&quot;: &quot;group:default/admins&quot;, &quot;target&quot;: { &quot;kind&quot;: &quot;group&quot;, &quot;namespace&quot;: &quot;default&quot;, &quot;name&quot;: &quot;admins&quot; } }, { &quot;type&quot;: &quot;memberOf&quot;, &quot;targetRef&quot;: &quot;group:default/developers&quot;, &quot;target&quot;: { &quot;kind&quot;: &quot;group&quot;, &quot;namespace&quot;: &quot;default&quot;, &quot;name&quot;: &quot;developers&quot; } }, ] },   OPA on AWS uses the Backstage schema (entity provider) to allow access, both on the Backstage platform and on AWS. Therefore, if you change the source which populates the Backstage identity schema, the behavior remains the same.  To configure LDAP with Backstage, consult the Backstage reference on LDAP Organizational Data  ","version":"Next","tagName":"h3"},{"title":"Populating Backstage identity schema​","type":1,"pageTitle":"Security","url":"/docs/techdocs/security#populating-backstage-identity-schema","content":" OPA on AWS uses the roadiehq catalog-backend-module-okta plugin to connect and update OKTA users and groups back to Backstage.  Here are some configuration options you may want to consider:  userNamingStrategy (i.e: strip-domain-email)groupNamingStrategy (i.e: kebab-case-name)hierarchyConfig (i.e: key: 'profile.orgId', parentKey: 'profile.parentOrgId')  Backstage Okta Provider Documentation  ","version":"Next","tagName":"h3"},{"title":"Backstage permission model​","type":1,"pageTitle":"Security","url":"/docs/techdocs/security#backstage-permission-model","content":" ","version":"Next","tagName":"h2"},{"title":"Introduction​","type":1,"pageTitle":"Security","url":"/docs/techdocs/security#introduction","content":" TODO  ","version":"Next","tagName":"h3"},{"title":"Restricting access to templates​","type":1,"pageTitle":"Security","url":"/docs/techdocs/security#restricting-access-to-templates","content":" TODO  ","version":"Next","tagName":"h3"},{"title":"Restricting access to kinds​","type":1,"pageTitle":"Security","url":"/docs/techdocs/security#restricting-access-to-kinds","content":" TODO  ","version":"Next","tagName":"h3"},{"title":"AWS Security​","type":1,"pageTitle":"Security","url":"/docs/techdocs/security#aws-security","content":" ","version":"Next","tagName":"h2"},{"title":"Introduction​","type":1,"pageTitle":"Security","url":"/docs/techdocs/security#introduction-1","content":" While there are different methodologies when it comes to security in the cloud, we adopted some of the approaches we have seen at our financial customers. These include:  Segregation of access controlsUse of temporary credentialsSeparation of duties and the least privileges principleUse of different AWS accounts to ensure default restrictionsSeparation of production/staging environments from development/sandbox environments  note The above principles are not a replacement for organization-level preventive and detective controls. It is recommended to use services like AWS Control Tower and Service Control Policies (SCPs) to have multiple layers of security from the developer platform throughout the organization governance and controls.  ","version":"Next","tagName":"h3"},{"title":"Environments and access to AWS services​","type":1,"pageTitle":"Security","url":"/docs/techdocs/security#environments-and-access-to-aws-services","content":" We define an environment as a &quot;place&quot; in AWS. Granting access to an environment will allow a user or process to gain access only to the resources of that environment, but not to other environments.  Definition of AWS Environment Provider:  Include all of the supporting software artifacts to run a particular type of workload (Container-based, Serverless, AI/ML etc..).Must reside within an AWS Account and a region.Must provide at least two roles to gain access to the environment resources: a Provisioning role and an Operations role.Mutually exclusive by design - One provider cannot access resources from another provider, even if they are configured to use the same AWS account and region.  There are several methods for a user to gain access to an environment:  Indirect access - throughout the developer platform and pipeline, a developer can perform actions on an allowed target environment. The platform/pipeline will assume the target environment roles and get temporary credentials to perform the actions on behalf of the user.      Direct access - a user can assume credentials directly to the target environment access roles (Provisioning roles, operations role)    Resource specific access - a user can assume access to a particular shared resource by the environment, such as: kubectl    info Environment provider authors can reason about the required set of permissions for provisioning and operating applications for this environment. OPA on AWS provides sample templates for AWS ECS, AWS EKS, and Serverless environment providers.  ","version":"Next","tagName":"h3"},{"title":"Diving deep to access roles trust policy​","type":1,"pageTitle":"Security","url":"/docs/techdocs/security#diving-deep-to-access-roles-trust-policy","content":" As described above, OPA on AWS provides a pattern of assuming access to particular AWS environments. Out of the box - When provisioning a new environment provider, the provisioning role and operations role are created and their trust policy is modified to enable the platform role and pipeline role respectively.  example of: commercial-us-commercial-dev-provisioning-role - Assumed by gitlab pipeline role  { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;AWS&quot;: &quot;arn:aws:iam::31**********:role/opa-platform-GitlabRunnerConstructGitlabRunnerIamR&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] }   example of: commercial-us-commercial-dev-operations-role - Assumed by the platform role  { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;AWS&quot;: &quot;arn:aws:iam::31**********:role/backstage-master-role&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] }   tip You can also configure these roles with federation to grant access to your users based on their membership in certain group that is set up for your identity provider. This can be done with SAML or WebIdentity - for more information, read here. ","version":"Next","tagName":"h3"},{"title":"Test Cases","type":0,"sectionRef":"#","url":"/docs/tests","content":"","keywords":"","version":"Next"},{"title":"Assumptions​","type":1,"pageTitle":"Test Cases","url":"/docs/tests#assumptions","content":" You have OPA on AWS platform deployed and running.You have several accounts that are used or can be used to provision environments and applications.You have an identity provider configured with backstage(Okta, AD, etc.)  ","version":"Next","tagName":"h2"},{"title":"Test case, context and expected result​","type":1,"pageTitle":"Test Cases","url":"/docs/tests#test-case-context-and-expected-result","content":" We define a context of a test with the letter &quot;C&quot;. This will allow us to describe the existing state before we can execute a test case.  We also define test case with the letter &quot;T&quot; which describe the set of instructions to test a scenario on OPA on AWS.  Lastly we define the expected result with the letter &quot;E&quot;, this will describe the expected assertion of a resulted test case.  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Test Cases","url":"/docs/tests#context","content":" ID\tDescriptionC01\tAn entitled user logged-in to backstage C02\tA provisioned ECS Environment(Single provider) is available C03\tA provisioned EKS Environment(Single provider) is available C04\tA provisioned Serverless Environment(Single provider) is available C05\tA provisioned AWS Environment is available C06\tA provisioned ECS application(Single environment) is available C07\tA provisioned EKS application(Single environment) is available C08\tA provisioned Serverless application(Single environment) is available C09\tA provisioned shared RDS Resource is available C10\tA provisioned shared S3 Resource is available C11\tA binding between an application and resource exist C12\tAn application is deployed to more than one environment C13\tA provisioned ECS Environment(Multi provider) is available C14\tA provisioned EKS Environment(Multi provider) is available C15\tA provisioned Serverless Environment(Multi provider) is available C16\tA provisioned ECS application(Multi environment) is available C17\tA provisioned EKS application(Multi environment) is available C18\tA provisioned Serverless application(Multi environment) is available C19\tA provisioned Terraform application/provider/resource C20\tUser chooses that a new VPC should be created C21\tUser chooses that an existing VPC ID should be used instead of creating a new VPC C22\tA provisioned EKS Cluster is available C23\tA provisioned EKS Cluster Kubectl Lambda is available  ","version":"Next","tagName":"h2"},{"title":"Expected result​","type":1,"pageTitle":"Test Cases","url":"/docs/tests#expected-result","content":" ID\tDescriptionE01\tSuccessfully provision an ECS provider E02\tSuccessfully provision an EKS provider E03\tSuccessfully provision an Serverless provider E04\tSuccessfully provision an Environment E05\tSuccessfully provision an ECS application(Single provider) E06\tSuccessfully provision an EKS application(Single provider) E07\tSuccessfully provision a Serverless application(Single provider) E08\tSuccessfully start and stop an application E09\tSuccessfully view application logs E10\tSuccessfully view application audit table E11\tSuccessfully set environment variables to an application E12\tSuccessfully view cloud related application resources E13\tSuccessfully bind a shared resource to an application E14\tSuccessfully deploy an application to additional environments E15\tSuccessfully toggle between deployed environments of an application E16\tSuccessfully delete an application from an environment E17\tSuccessfully delete an application from all environments E18\tSuccessfully delete a shared resource E19\tSuccessfully delete a provider E20\tSuccessfully delete an environment E21\tSuccessfully view provider details E22\tSuccessfully unbind a shared resource to an application E23\tA new VPC is created for the provider E24\tAn existing VPC ID is used by the provider E25\tSuccessfully provision an RDS database as a shared resource E26\tSuccessfully provision an S3 bucket as a shared resource E27\tSuccessfully create EKS provider using existing EKS cluster and create new kubectl lambda E28\tSuccessfully create EKS provider using existing EKS cluster and existing kubectl lambda  ","version":"Next","tagName":"h2"},{"title":"Test cases​","type":1,"pageTitle":"Test Cases","url":"/docs/tests#test-cases-1","content":" ","version":"Next","tagName":"h2"},{"title":"Platform engineering​","type":1,"pageTitle":"Test Cases","url":"/docs/tests#platform-engineering","content":" Environment Providers​  ID\tContext\tDescription\tExpected ResultT001\tC01+C20\tProvision an ECS environment provider with serverless compute (Fargate)\tE01+E23 T002\tC01+C21\tProvision an ECS environment provider with serverless compute (Fargate)\tE01+E24 T003\tC01+C20\tProvision an ECS environment provider with EC2 compute\tE01+E23 T004\tC01+C20\tProvision an EKS environment provider with serverless compute (Fargate)\tE02+E23 T005\tC01+C21\tProvision an EKS environment provider with serverless compute (Fargate)\tE02+E24 T006\tC01\tProvision an EKS environment provider with managed nodes\tE02 T007\tC01\tProvision an EKS environment provider with private-only API access\tE02 T008\tC01+C20\tProvision a Serverless environment provider\tE03+E23 T009\tC01+C21\tProvision a Serverless environment provider\tE03+E24 T010\tC01+(C02,C03,C04)\tView provider information card - on provider page\tE21 T011\tC01+(C02,C03,C04)\tDelete provider - on provider management page\tE19 T012\tC01+C22\tProvision an EKS environment provider and import an existing cluster and create kubectl lambda\tE27 T013\tC01+C22+C23\tProvision an EKS environment provider and import an existing cluster and reuse existing kubectl lambda\tE28  Environments​  ID\tContext\tDescription\tExpected ResultT200\tC01\tProvision an AWS environment with a single provider\tE04 T201\tC01+C05\tView environment information card - on environment page\tE21 T202\tC01+C05\tDelete environment - on environment management page\tE21 T203\tC01+C05\tAdd additional provider to an existing environment - on environment page\tE19 T204\tC01+C05\tDelete a provider from an existing environment - on environment page\tE19  ","version":"Next","tagName":"h3"},{"title":"Developer​","type":1,"pageTitle":"Test Cases","url":"/docs/tests#developer","content":" Application Provisioning​  ID\tContext\tDescription\tExpected ResultT400\tC01 + C02\tProvision a node.js application on AWS ECS environment with a single provider\tE05 T401\tC01 + C02\tProvision a Java SpringBoot application on AWS ECS environment with a single provider\tE05 T402\tC01 + C02\tProvision a python application on AWS ECS environment with a single provider\tE05 T403\tC01 + C02\tProvision a node.js Terraform application on AWS ECS environment with a single provider\tE05 T404\tC01 + C03\tProvision a node.js application on AWS EKS environment with a single provider\tE06 T405\tC01 + C03\tProvision a Java SpringBoot application on AWS EKS environment with a single provider\tE06 T406\tC01 + C03\tProvision a python application on AWS EKS environment with a single provider\tE06 T407\tC01 + C03\tProvision a node.js Terraform application on AWS EKS environment with a single provider\tE06 T408\tC01 + C04\tProvision a Serverless REST API application on AWS Serverless environment with a single provider\tE07  Application operations​  ID\tContext\tDescription\tExpected ResultT600\tC06\tStart and Stop the application\tE08 T601\tC06\tView application cloudwatch logs - on App logs tab\tE09 T602\tC06\tView application audit table - on audit tab\tE10 T603\tC06\tAdd/edit/delete environment variables for the application\tE11 T604\tC06\tView related cloud resources for the application\tE12 T605\tC06 + C02\tDeploy application to another available environment\tE14 T606\tC06 + C12\tToggle between deployed environments for the application\tE15 T607\tC06\tDelete an application from an environment\tE16 T608\tC06 + C12\tDelete an application from all environments\tE17 T609\tC06 + C09\tBind a shared resource RDS to an application\tE13 T610\tC06 + C09 + C11\tUnbind a shared resource from an application\tE22 T611\tC07\tStart and Stop the application\tE08 T612\tC07\tView application cloudwatch logs - on App logs tab\tE09 T613\tC07\tView application audit table - on audit tab\tE10 T614\tC07\tAdd/edit/delete environment variables for the application\tE11 T615\tC07\tView related cloud resources for the application\tE12 T616\tC07 + C02\tDeploy application to another available environment\tE14 T617\tC07 + C12\tToggle between deployed environments for the application\tE15 T618\tC07\tDelete an application from an environment\tE16 T619\tC07 + C12\tDelete an application from all environments\tE17 T620\tC07 + C09\tBind a shared resource RDS to an application\tE13 T621\tC07 + C09 + C11\tUnbind a shared resource from an application\tE22  ","version":"Next","tagName":"h3"},{"title":"Shared resources​","type":1,"pageTitle":"Test Cases","url":"/docs/tests#shared-resources","content":" ID\tContext\tDescription\tExpected ResultT900\tC01+(C02,C03,C04)\tCreate a new RDS database resource\tE25 T901\tC01+(C02,C03,C04)\tCreate a new S3 bucket resource\tE26 ","version":"Next","tagName":"h3"},{"title":"Application Environment Tutorial","type":0,"sectionRef":"#","url":"/docs/tutorials/create-environments","content":"","keywords":"","version":"Next"},{"title":"Create an Environment Provider​","type":1,"pageTitle":"Application Environment Tutorial","url":"/docs/tutorials/create-environments#create-an-environment-provider","content":" We're going to start with creating a new AWS Environment Provider.  In the default OPA on AWS solution used by this tutorial, the Infrastructure as Code source and CI/CD pipelines responsible for provisioning infrastructure have already been created and reside in a GitLab reference repository.  We'll use an AWS ECS Environment Provider template to provision our AWS Elastic Container Service (ECS) runtime environment.  1. Click the Create.. menu on the left and Choose the AWS ECS Environment Provider template.    2. Provide input parameters to tailor the environment provider resources.  Parameter\tValue\tDescriptionName\tecs-dev-provider\tA unique identifier for the environment provider Prefix\tecsdev\tA short prefix used for AWS resource creation Description\tA Dev environment provider for containerized applications\tDescribes what the environment provider's purpose will be Owner\tSelect a group from the drop-down list to own the Environment Provider\tThe group or user that will be responsible for the entity AWS Account Number\tEnter your 12-digit AWS account id\tThe AWS account where the environment provider will be created AWS Region\tSelect the same region where you have deployed the OPA on AWS solution\tThe AWS region to provision resources in Environment role arn\tEnter the ARN of an IAM role with sufficient permission to deploy AWS infrastructure. A sample role named opa-envprovisioning-role was created when deploying the OPA on AWS solution. The ARN format should be similar to arn:aws:iam::{AWS_ACCOUNT_ID}:role/{IAM_ROLE_NAME}\tThe IAM role to be used for provisioning AWS resources in the target account and region CIDR\t10.0.0.0/24 (default)\tThe CIDR block to be provisioned for the VPC associated with the ECS cluster to be created    3. Select Next Step and Provide Repository information  In this step we provide information about the git repository where the Environment Provider source files will be published as part of executing the Software Template.  Parameter\tValue\tDescriptionHost:\tdefault value\tThe GitLab host name Owner:\tdefault value\tThe GitLab namespace where this repository will belong to. It can be the name of organization, group, subgroup, user, or the project Repository:\tecs-dev-provider\tThe name for the git repository    4. Select Next Step, review your inputs and select Create.    5. Environment Provider Entity Creation  Upon clicking Create, the template starts executing automated action steps. It gets info from AWS, fetches ECS infrastructure code and other configuration files from the reference repository, updates configuration inside these files, and sets up a new git repository to store the files.    Once this git folder is ready, a CI/CD process will start automatically. It will use the infrastructure code in the git repository to provision your new ECS platform.  Now, let's proceed to the next step to create an environment using the environment provider entity we just created.  ","version":"Next","tagName":"h2"},{"title":"Create an Environment​","type":1,"pageTitle":"Application Environment Tutorial","url":"/docs/tutorials/create-environments#create-an-environment","content":" To create an Environment Entity we will use the AWS Environment template from the software catalog section.  1. On the OPA on AWS website, navigate to the Create.. menu. From the list of available templates, choose the AWS Environment template card.    2. Provide input parameters to tailor the environment entity and click Next Step  Parameter\tValue\tDescriptionName\tecs-dev\tA unique identifier for the environment Short Name\tecsdev\tA short identifier used for identification of environments Description\tDevelopment environment for containerized applications deployed to ECS\tDescribes the purpose of the environment Environment Type\tAWS ECS\tSpecifies the type of applications that can be deployed and managed in this environment Deployment Requires Approval\tNo\tAllows for blocking a CI/CD pipeline until approval is received. This is often set to 'No' for development and test, but 'Yes' for production Owner\tSelect a group from the drop-down list to own the Environment\tThe group or user that will be responsible for the entity. Account Type\tSingle-account\tIndicates whether the environment supports one or more accounts Region Type\tSingle-region\tIndicates whether the environment supports one or more regions Category\tDevelopment\tIdentifies the intended purpose of the environment (dev, test, prod, etc) Classification\tpublic\tIdentifies visibility of the environment (public-facing, internal-facing, or private) System\tdemo\tIdentifies the relationship of this environment to a larger system. This can be used to group environments together. Hierarchy of the Environment\t1\tValue used to determine relative ordering for environments. Typical approaches are to use lower numbers for development and higher numbers for production. Providers\tecs-dev-provider\tSelects one or more environment providers to attach to this environment. In this tutorial, there may only one environment provider available, so the drop-down list is disabled and the available environment provider will be used.    2. Click Next Step and fill in the remaining information:  Parameter\tValue\tDescriptionHost\tdefault value\tThe GitLab host name Owner\tdefault value\tThe GitLab namespace where this repository will belong to. It can be the name of organization, group, subgroup, user, or the project Repository\tecs-dev\tThe name for the git repository    3. Click Next Step and review your inputs. Click Create    4. The template scaffolding action will fetch a catalog-info.yaml file (used to define entities), replace the placeholders with our input we just provided, push the file to a new repo, and register it to the Backstage catalog.    Now that our Environment Entity is created, our developers can discover and point to the it during their app scaffolding process. Let's proceed to the next step and explore the ECS Environment Entity we just created. ","version":"Next","tagName":"h2"},{"title":"Create Resources","type":0,"sectionRef":"#","url":"/docs/tutorials/create-resources","content":"","keywords":"","version":"Next"},{"title":"Creating an RDS Database resource​","type":1,"pageTitle":"Create Resources","url":"/docs/tutorials/create-resources#creating-an-rds-database-resource","content":" 1. In the OPA on AWS interface, select the Create... menu option in the left navigation. Search for and choose the AWS RDS Database template.    2. Provide information about the resource and select Next Step  Parameter\tValue\tDescriptionName\tdemo-db\tA unique identifier for the database Description\tA database for demonstration data\tDescribes the database's purpose Owner\tSelect a group from the drop-down list to own the Resource\tThe group or user that will be responsible for the entity    3. Next, provide deployment information for the resource and select Next Step  Parameter\tValue\tDescriptionAWS Environment\tthe ecs-dev environment will be pre-selected since it is the only environment available\tThe AWS Environment in which you want to deploy your application to. The environment that we created in a previous tutorial will already be selected for you    4. Provide database configuration information and select Next Step  Parameter\tValue\tDescriptionDatabase Name\tdemodb\tThe name of a default database to create in the RDS instance Object Name\tuser\tThe name of the object that you will track in the default database. Database Engine\tSelect PostgreSQL\tThe engine of the SQL database Database Size\tSelect Small (20GB)\tThe size of the database that will be deployed    5. Provide Repository information and select Next StepChoose a repository for this database's infrastructure source code and entity information - you can use demo-db  6. Create the database by clicking the Create button    The template scaffolding action will fetch a catalog-info.yaml file (used to define entities), replace the placeholders with our input we just provided, push the file to a new repo, and register it to the Backstage catalog. A CI/CD pipeline in our new repository will begin executing to provision the new database. You can monitor the progress of the pipeline in the &quot;CI/CD&quot; tab of the new resource entity. ","version":"Next","tagName":"h2"},{"title":"Videos","type":0,"sectionRef":"#","url":"/docs/videos","content":"","keywords":"","version":"Next"},{"title":"YouTube playlist​","type":1,"pageTitle":"Videos","url":"/docs/videos#youtube-playlist","content":"   ","version":"Next","tagName":"h2"},{"title":"Decks​","type":1,"pageTitle":"Videos","url":"/docs/videos#decks","content":" OPA on AWS - Part 1 - IntroductionOPA on AWS - Part 2 - Platform engineeringOPA on AWS - Part 3 - Application developerOPA on AWS - Part 4 - Deploy Application to other environmentsOPA on AWS - Part 5 - Provision AWS Resources and resource bindingOPA on AWS - Part 6 - Deploying Serverless APIsOPA on AWS - Part 7 - OPA Security and RBACOPA on AWS - Part 8 - Orchestrating and Managing CI-CDOPA on AWS - Part 9 - Using Terraform to Orchestrate ApplicationsOPA on AWS - Part 10 - Customizing your platform - Adding providersOPA on AWS - Part 11 - Customizing your platform - Adding Templates  ","version":"Next","tagName":"h3"},{"title":"Individual videos​","type":1,"pageTitle":"Videos","url":"/docs/videos#individual-videos","content":" ","version":"Next","tagName":"h2"},{"title":"Introduction​","type":1,"pageTitle":"Videos","url":"/docs/videos#introduction","content":"   ","version":"Next","tagName":"h3"},{"title":"Platform Engineering​","type":1,"pageTitle":"Videos","url":"/docs/videos#platform-engineering","content":"   ","version":"Next","tagName":"h3"},{"title":"Application Developer​","type":1,"pageTitle":"Videos","url":"/docs/videos#application-developer","content":"   ","version":"Next","tagName":"h3"},{"title":"Deploy an Application to other Environments​","type":1,"pageTitle":"Videos","url":"/docs/videos#deploy-an-application-to-other-environments","content":"   ","version":"Next","tagName":"h3"},{"title":"Provision AWS Resources and Resource Binding​","type":1,"pageTitle":"Videos","url":"/docs/videos#provision-aws-resources-and-resource-binding","content":"   ","version":"Next","tagName":"h3"},{"title":"Deploying Serverless APIs​","type":1,"pageTitle":"Videos","url":"/docs/videos#deploying-serverless-apis","content":"   ","version":"Next","tagName":"h3"},{"title":"OPA Security and RBAC​","type":1,"pageTitle":"Videos","url":"/docs/videos#opa-security-and-rbac","content":"   ","version":"Next","tagName":"h3"},{"title":"Orchestrating and Managing CI/CD​","type":1,"pageTitle":"Videos","url":"/docs/videos#orchestrating-and-managing-cicd","content":"   ","version":"Next","tagName":"h3"},{"title":"Using Terraform to Orchestrate Applications​","type":1,"pageTitle":"Videos","url":"/docs/videos#using-terraform-to-orchestrate-applications","content":"   ","version":"Next","tagName":"h3"},{"title":"Customizing your platform - Adding providers​","type":1,"pageTitle":"Videos","url":"/docs/videos#customizing-your-platform---adding-providers","content":"   ","version":"Next","tagName":"h3"},{"title":"Customizing your platform - Adding Templates​","type":1,"pageTitle":"Videos","url":"/docs/videos#customizing-your-platform---adding-templates","content":"  ","version":"Next","tagName":"h3"},{"title":"Entities","type":0,"sectionRef":"#","url":"/docs/techdocs/entities","content":"","keywords":"","version":"Next"},{"title":"AWS Environment & Environment Provider​","type":1,"pageTitle":"Entities","url":"/docs/techdocs/entities#aws-environment--environment-provider","content":" These custom Backstage entity kinds were created to represent an abstract AWS environment and environment provider.  ","version":"Next","tagName":"h2"},{"title":"AWS Environment​","type":1,"pageTitle":"Entities","url":"/docs/techdocs/entities#aws-environment","content":" An abstracted entity that captures the intent of use of a particular environment instance, including:  Single/multi account.Single/multi region.Category – dev, test, stage, prod etc.Classification – private, internal, public.Requires approval - for automated pipeline deployments.System - for participation in higher level systems.Hierarchy – where does it position in the hierarchy of other environments (low – dev, high – prod).  info AWS Environment Entity Definition: AWSEnvironmentEntityV1.ts  AWS Environment Principles:  Maintain 1:N relationship with AWS environment providers.Integrated with pipeline definitions for deployments that require approval.Customizable and extendable.Can be used with different types of Environment Providers.  AWSEnvironmentEntityV1.ts export interface AWSEnvironmentEntityV1 extends Entity { apiVersion: 'aws.backstage.io/v1alpha'; kind: 'AWSEnvironment'; spec: { ... } }   AWS Environment enforces the creation of a relationship with environment providers through the entity Processor  AWSEnvironmentEntitiesProcessor.ts if (targetRef.kind == 'awsenvironmentprovider') { emit( processingResult.relation({ source: selfRef, type: RELATION_DEPENDS_ON, target: { kind: targetRef.kind, namespace: targetRef.namespace, name: targetRef.name, }, }), ); emit( processingResult.relation({ source: { kind: targetRef.kind, namespace: targetRef.namespace, name: targetRef.name, }, type: RELATION_DEPENDENCY_OF, target: selfRef, }), ); }   info AWS Environment Processor code: AWSEnvironmentEntitiesProcessor.ts  ","version":"Next","tagName":"h3"},{"title":"AWS Environment Provider​","type":1,"pageTitle":"Entities","url":"/docs/techdocs/entities#aws-environment-provider","content":" A custom kind entity that captures a place in the cloud that can be used to provision and run applications. An Environment provider can be defined by:  A particular AWS AccountA particular AWS RegionA name and prefix composition for organization segmentation (payments:development, hr:production etc.)Mutually exclusive – multiple distinct providers can be created within a single AWS account and regionIsolated from other providers / accountsProvisioning role - a role that has sufficient permissions to provision the resources for the designated types of applications.Operations role - a role that has sufficient permissions to operate the designated types of applications.Audit table - a dedicated table to capture the actions performed on the applications running in the current environment.Optional: The underlying networking (VPC), runtime environment (ECS/EKS/Serverless), and required applications infrastructure      info AWS Environment Provider Entity Definition: AWSEnvironmentProviderEntityV1.ts  AWSEnvironmentEntityV1.ts export interface AWSEnvironmentProviderEntityV1 extends Entity { apiVersion: 'aws.backstage.io/v1alpha'; kind: 'AWSEnvironmentProvider'; spec: { ... } }   info AWS Environment Provider Processor code: AWSEnvironmentProviderEntitiesProcessor.ts  ","version":"Next","tagName":"h3"},{"title":"Components​","type":1,"pageTitle":"Entities","url":"/docs/techdocs/entities#components","content":" We map applications to the existing Backstage entity component. While the concept of an application can be interpreted in different ways, we found the kind component to be very close to it.  ","version":"Next","tagName":"h2"},{"title":"The structure of application component entity:​","type":1,"pageTitle":"Entities","url":"/docs/techdocs/entities#the-structure-of-application-component-entity","content":" When provisioning an application, the template creates a Backstage catalog info yaml file with the below properties:  apiVersion: backstage.io/v1alpha1 kind: Component metadata: name: &quot;Your App name&quot; description: &quot;Description&quot; tags: - aws - nodejs iacType: cdk repoSecretArn: &quot;arn:aws:secretsmanager:us-east-1:**********.:secret:***&quot; spec: type: aws-app owner: &quot;group:default/developers&quot; lifecycle: experimental dependsOn: [FirstDeployedEnvironment]   We introduce a new component spec type - aws-app which will be used to mark applications that run on AWS. This is used to provide a specific UI experience that allows users to operate the application in the AWS cloud.  The iacType property indicates the type of the infrastructure as code this app was provisioned with - this impacts both the pipeline as well as the UI experience that are based on Terraform or CDK (state management).  tip You may notice that repoSecretArn is created regardless of the environment where the application is deployed - that is because the access to the repository is part of the platform / solution account regardless of where is it being deployed.  After the application provisioning pipeline completes, the pipeline will update the entity with the environment deployed resources under the appData tag:  apiVersion: backstage.io/v1alpha1 kind: Component metadata: name: &quot;AML-Detection-EMEA&quot; description: &quot;AML Detection App for EMEA&quot; tags: - aws - nodejs annotations: aws.amazon.com/opa-repoSecretArn: &quot;arn:aws:secretsmanager:us-east-1:**********.:secret:aws-apps-aml-detection-emea-access-token-V9w8Ea&quot; iacType: cdk repoSecretArn: &quot;arn:aws:secretsmanager:us-east-1:**********.:secret:aws-apps-aml-detection-emea-access-token-V9w8Ea&quot; appData: EMEA-AML-dev: emea-aml-dev: EcrRepositoryUri: **********.dkr.ecr.eu-west-1.amazonaws.com/aml-detection-emea-emea-aml-dev EcrRepositoryArn: arn:aws:ecr:eu-west-1:**********.:repository/aml-detection-emea-emea-aml-dev EcsServiceArn: arn:aws:ecs:eu-west-1:**********.:service/aml-emea-aml-dev-cluster/AML-Detection-EMEA-emea-aml-dev EcsTaskDefinitionArn: arn:aws:ecs:eu-west-1:**********.:task-definition/******:1 AlbEndpoint: http://AML-D-AMLDe-11C7BFBPF0RHP-**********..eu-west-1.elb.amazonaws.com TaskLogGroup: /aws/apps/EMEA-AML-dev/emea-aml-dev/AML-Detection-EMEA TaskExecutionRoleArn: AML-Detection-EMEA-ecs-resources-emea-aml-dev/AML-Detection-EMEA-taskDef/ExecutionRole AppResourceGroup: arn:aws:resource-groups:eu-west-1:**********.:group/AML-Detection-EMEA-emea-aml-dev-rg StackName: AML-Detection-EMEA-ecs-resources-emea-aml-dev EMEA-AML-test: emea-aml-test: EcrRepositoryUri: **********..dkr.ecr.eu-west-1.amazonaws.com/aml-detection-emea-emea-aml-test EcrRepositoryArn: arn:aws:ecr:eu-west-1:**********.:repository/aml-detection-emea-emea-aml-test EcsServiceArn: arn:aws:ecs:eu-west-1:**********.:service/aml-emea-aml-test-cluster/AML-Detection-EMEA-emea-aml-test EcsTaskDefinitionArn: arn:aws:ecs:eu-west-1:**********.:task-definition/*****:1 AlbEndpoint: http://AML-D-AMLDe-HNBIDJ2F0QER-**********.eu-west-1.elb.amazonaws.com TaskLogGroup: /aws/apps/EMEA-AML-test/emea-aml-test/AML-Detection-EMEA TaskExecutionRoleArn: AML-Detection-EMEA-ecs-resources-emea-aml-test/AML-Detection-EMEA-taskDef/ExecutionRole AppResourceGroup: arn:aws:resource-groups:eu-west-1:**********.:group/AML-Detection-EMEA-emea-aml-test-rg StackName: AML-Detection-EMEA-ecs-resources-emea-aml-test spec: type: aws-app owner: &quot;group:default/developers&quot; lifecycle: experimental dependsOn: ['awsenvironment:default/EMEA-AML-dev', 'awsenvironment:default/EMEA-AML-test']   tip You may notice that the example above describes an entity of an application that is deployed in two environments: EMEA-AML-dev and EMEA-AML-test  Similiarly a serverless application entity will look like :  apiVersion: backstage.io/v1alpha1 kind: Component metadata: name: &quot;snacks&quot; kebabName: &quot;snacks&quot; description: &quot;get a list of yummy snack foods&quot; tags: - aws - rest - swagger - openapi - apigateway - serverless iacType: cdk repoSecretArn: &quot;arn:aws:secretsmanager:us-east-1:**********:secret:aws-apps-snacks-access-token-0IMiXR&quot; appData: api-team-dev: api-team-dev: AppResourceGroup: arn:aws:resource-groups:us-east-1:**********::group/snacks-api-team-dev-rg StackName: snacks-serverless-api-resources-api-team-dev AppStackName: snacks-api-team-dev BuildBucketName: snacks-serverless-api-re-snacksapiteamdevbuildbuc-********** api-team-qa: api-team-qa: AppResourceGroup: arn:aws:resource-groups:us-east-1:**********:group/snacks-api-team-qa-rg StackName: snacks-serverless-api-resources-api-team-qa AppStackName: snacks-api-team-qa BuildBucketName: snacks-serverless-api-re-snacksapiteamqabuildbuck-********** spec: type: aws-app owner: &quot;group:default/developers&quot; lifecycle: experimental dependsOn: ['awsenvironment:default/api-team-dev', 'awsenvironment:default/api-team-qa']   ","version":"Next","tagName":"h3"},{"title":"Resource​","type":1,"pageTitle":"Entities","url":"/docs/techdocs/entities#resource","content":" Backstage resource entities are used to illustrate AWS resources. However, we extended the model so that we can articulate specific UI and processes that won't conflict with Backstage built-in capabilities of Resource entities.  Resource entity catalog:  apiVersion: backstage.io/v1alpha1 kind: Resource metadata: name: &quot;Commercial-Pymt-db-us&quot; description: &quot;Payment DB for commercial apps in US&quot; tags: - aws - rds - aws-resource - database annotations: null iacType: cdk resourceType: &quot;aws-rds&quot; dbName: &quot;pymtdb&quot; dbObjectName: &quot;user&quot; appData: US-Commercial: us-commercial-dev: Arn: arn:aws:rds:us-east-1:**********:db:commercial-pymt-db-us-rds-reso-rdsinstance05f4b4b0-********** DbAdminSecretArn: arn:aws:secretsmanager:us-east-1:**********:secret:rdsInstanceSecretB79B16A5-**********-Y8ykm1 DbEndpoint: commercial-pymt-db-us-rds-reso-rdsinstance05f4b4b0-xwcil8gg8rvp.**********.us-east-1.rds.amazonaws.com DbPort: '5432' ResourceGroup: arn:aws:resource-groups:us-east-1:**********:group/Commercial-Pymt-db-us-us-commercial-dev-rg StackName: Commercial-Pymt-db-us-rds-resource spec: type: aws-resource owner: &quot;group:default/dev-ops&quot; lifecycle: experimental dependsOn: ['awsenvironment:default/US-Commercial']   Core resource entity properties:  spec/type -&gt; aws-resource . while we use the same kind of Resource the spec type refers to aws-resource which can be easily used to filter our AWS related resources.resourceType this is used to capture the different types of AWS resources including: aws-rds, s3, sns, sqs etc.  Extended resource entity properties:  dbName - in this aws-rds resource the property captures the database namedbObjectName in this aws-rds resource the property captures the schema/user nameappData - under this property, all deployed resource artifacts are preserved - you can customize what properties you would like to bring back to the entity from the provisioning pipeline.  note AWS Resources are provisioned against a single environment. The process of deploying a resource to an additional environment is not supported to avoid managing different configurations or changes of the resource that are not identical across multiple environments. ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}